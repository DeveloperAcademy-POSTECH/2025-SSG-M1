1. **==할당 연산자==**
= 값 할당 (예: a = b)
+= 복합 할당 연산자 (예: a += 5 는 a = a +5 와 동일)
-=
\*=
/=
%=

2. **==산술 연산자==**
\+ 덧셈
\- 뺄셈
\* 곱셈
/ 나눗셈 연산
% 나머지 연산 (예: 9 % 4 는 몫 2와 나머지 1이므로, 1이 반환됨 )

[단항 연산자]
+, - (예: +a, 양수임을 명시, -a, 음수임을 명시)

3. **==비교 연산자==**
== 같음
!= 다름
\> 보다 큼
\< 보다 작음
\>= 보다 크거나 같음
\<= 보다 작거나 같음
=== 동일 (구조체(struct)나 열거형(enum)에는 사용할 수 없습니다.)
!== 동일하지 않음

\* \==와 \=\==의 차이
\==은 값을 비교하고, \=\==는 같은 인스턴스(객체)를 참조하는지 비교한다. (즉, 메모리 상의 같은 위치를 가리키는지)

```
class MyClass { 
	var value: Int 
	init(value: Int) { 
		self.value = value 
	} 
} 

let obj1 = MyClass(value: 10) 	let obj2 =MyClass(value: 10) 
let obj3 = obj1 

print(obj1 === obj2) // false (내용은 같지만 다른 인스턴스) 
print(obj1 === obj3) // true (같은 인스턴스를 참조)
```

\** class 이해
var value: Int 
 - 클래스의 속성(Property)을 정의하는 부분입니다.
init(value: Int) { self.value = value } 
 - value값을 받아와 초기화(init)한다. 
 - self.value란 해당 class의 value값을 의미한다. 이것을 받아온 = value (괄호 안의 value 값)으로 할당한다는 뜻이다.
 
4. **==논리 연산자==**
! Not 연산자
&& and 연산자
|| Or 연산자

5. **==범위 연산자==**
a...b 닫힌 범위 연산자 (a부터 b까지, a, b 포함)
a..<b 반 열림 범위 연산자 (a부터 b 직전까지, b미포함)
a... 한쪽만 열린 범위 연산자 (a부터 끝까지)
...a  한쪽만 열린 범위 연산자 (시작부터 a까지)

6. **==비트 연산자==**
~ 비트 not 연산자
: 주어진 숫자의 모든 비트를 반전시킵니다. (0은 1로, 1은 0으로). 정수 타입에만 적용됩니다.

```
let num: UInt8 = 0b00001111 // 10진수 15
let invertedNum = ~num       // 0b11110000 // 10진수 240
```

\* UInt8이란? 
부호 없는 8비트 정수(Unsigned 8-bit Integer)
부호가 없다: 음수를 표현할 수 없고, 0또는 양수만 표현할 수 있다
8비트로 표현할 수 있는 값의 범위: 2의 8승 = 256
따라서 `UInt8`의 값 범위는 0부터 255까지

\*\*Swift의 정수 타입 종류
- 부호 있는 정수 (Signed Integers): `Int8`, `Int16`, `Int32`, `Int64`, `Int` (기본 정수 타입, 플랫폼에 따라 32비트 또는 64비트)
- 부호 없는 정수 (Unsigned Integers): `UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt` (기본 부호 없는 정수 타입)
- `Int8`의 정확한 범위는 −128부터 127까지

& 비트 and 연산자
: 두 피연산자의 해당 비트가 모두 1일 경우에만 결과 비트를 1로 설정합니다.

```
let a: UInt8 = 0b10101010 // 10진수 170 
let b: UInt8 = 0b11110000 // 10진수 240 
let result = a & b  // 0b10100000 // 10진수 160 
print(String(result, radix: 2))
```

\* 0b는 2진법으로 적힌 수라는 걸 표현
2진수 (Binary): `0b` 접두사 (예: `0b10101010`)
8진수 (Octal): `0o` 접두사 (예: `0o17`)
16진수 (Hexadecimal): `0x` 접두사 (예: `0xFF`)

\*radix:2의 의미는 result 값을 2진수로 변환하라는 의미

| 비트 or 연산자
: 두 연산자의 해당 비트 중 하나라도 1일 경우 결과 비트를 1로 설정

```
let a: UInt8 = 0b10101010 
let b: UInt8 = 0b11110000 
let result = a | b  // 0b11111010 // 10진수 250 
print(String(result, radix: 2))
```

^ 비트 XOR연산자
: 두 피연산자의 해당 비트가 다를 경우에만 비트를 1로 설정

```
let a: UInt8 = 0b10101010 
let b: UInt8 = 0b11110000 
let result = a ^ b  // 0b01011010 // 10진수 90 
print(String(result, radix: 2))
```

<< 왼쪽 비트 시프트 연산자
:비트를 왼쪽으로 지정된 횟수만큼 이동시킵니다. 오른쪽에는 0이 채워집니다. 숫자를 2의 n승만큼 곱하는 효과가 있습니다.

```
let num: UInt8 = 0b00001111 // 10진수 15 
let shifted = num << 2  // 0b00111100 // 10진수 60 (15 * 2^2)
print(String(shifted, radix: 2))
```

\>> 오른쪽 비트 시프트 연산자
:비트를 오른쪽으로 지정된 횟수만큼 이동시킵니다. 양수의 경우 왼쪽에는 0이 채워집니다. 숫자를 2의 n승만큼 나누는 효과가 있습니다.

```
let num: UInt8 = 0b00001111 // 10진수 15 
let shifted = num << 2  // 0b00111100 // 10진수 60 (15 * 2^2)
print(String(shifted, radix: 2))

// 음수의 경우 (Int 타입) 
let negativeNum: Int8 = -16 // 0b11110000 (2의 보수 표현) 
let shiftedNegative = negativeNum >> 2 // -4 (0b11111100) 
print(shiftedNegative)
```

**==7.기타 연산자**==
`조건 ? 값1 : 값2`삼항 조건 연산자 (조건이 참이면 `값1`을, 거짓이면 `값2`를 반환)
`a ?? b` Nil-병합 연산자 (`a`가 `nil`이 아니면 `a`를, `nil`이면 `b`를 반환)

[오버 플로우 연산자]
&+ 오버 플로우 덧셈 연산자
: 오버플로우를 허용하는 덧셈 연산입니다. 정수 타입의 최대값 또는 최소값을 넘어설 때, Swift의 기본 동작(런타임 에러)과 달리 오버플로우를 감싸서 처리합니다. 예를 들어, `UInt8`의 최댓값(255)을 넘어가면 0부터 다시 시작합니다.

```
var num: UInt8 = 255 
num = num &+ 1 // 255 + 1 = 256인데, UInt8은 0~255이므로 오버플로우 되어 0이 됨
print(num) // 출력: 0
```

&- 오버 플로우 뺼셈 연산자

```
var num: UInt8 = 0 
num = num &- 1 // 0 - 1 = -1인데, UInt8은 0~255이므로 언더플로우 되어 255가 됨 
print(num) // 출력: 255
```

&* 오버 플로우 곱셈 연산자

```
var num: UInt8 = 100 
num = num &* 3 // 100 * 3 = 300인데, UInt8은 0~255이므로 오버플로우 되어 44가 됨 (300 % 256) 
print(num) // 출력: 44
```

&<< 오버 플로우 왼쪽 시프트 연산자
```
let num: UInt8 = 0b10000000 // 10진수 128 
let shifted = num &<< 1  // 0b00000000 (128을 한 칸 왼쪽으로 시프트하면 256이 되지만, UInt8 범위 초과로 오버플로우 되어 0이 됨) 
print(String(shifted, radix: 2)) // 출력: 00000000
```

&>> 오버플로우 오른쪽 비트 시프트 연산자
