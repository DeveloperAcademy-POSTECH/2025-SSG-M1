#### **1. 함수란 무엇이며 왜 사용해야 하는가?**

- **정의:** 함수는 프로그램의 나머지 부분에서 분리하여 쉽게 참조할 수 있도록 이름을 붙인 코드 조각입니다. 즉, 여러 번 사용하고 싶은 코드 덩어리를 묶어 이름 지은 것입니다.
- **목적 및 장점:**
    - **코드 재사용:** 동일한 기능을 여러 곳에서 구현해야 할 때 코드를 복사하여 붙여넣을 필요 없이 함수를 호출하여 재사용할 수 있습니다.
    - **코드 중복 감소:** 코드 중복이 줄어들어 더 간결한 코드를 작성할 수 있습니다.
    - **유지보수 용이성:** 함수를 변경하면 (예: 더 많은 작업을 추가) 해당 함수를 사용하는 모든 곳에 자동으로 새로운 동작이 적용되므로, 업데이트를 잊어버릴 위험이 없습니다.
    - **가독성 및 조직화:** 긴 코드를 작고 관리하기 쉬운 함수로 나누면 전체 내용을 이해하기 더 쉬워집니다.
    - **유연성:** 함수에 데이터를 전달하여 동작 방식을 사용자 정의할 수 있으며, 계산된 결과를 반환하여 알려줄 수 있습니다.
    - **함수 합성 (Function Composition):** 기존 함수를 기반으로 새로운 함수를 만들 수 있습니다. 작은 함수들을 조합하여 더 큰 함수를 만들 수 있어, 코드를 레고 블록처럼 유연하게 구성할 수 있습니다.

---

#### **2. 함수의 정의 및 호출**

- **정의:**
    - 함수는 `func` 키워드로 시작합니다.
    - `func` 뒤에 함수 이름을 지정합니다 (예: `showWelcome`). 함수 이름은 기억하기 쉬운 것이 좋습니다 (예: `printInstructions`, `displayHelp`).
    - 함수 이름 뒤에는 괄호 `()`가 붙습니다. 이 괄호는 함수에 `configuration options`(구성 옵션)을 추가하여 함수의 동작을 사용자 정의할 때 사용됩니다.
    - 함수의 실제 코드는 중괄호 `{}` 안에 포함됩니다. 이를 함수의 **본문(body)**이라고 합니다.
    - **예시:**
        
        ```
        func showWelcome() {
            print("Welcome to my app!")
            print("By default This prints out a conversion")
            print("chart from centimeters to inches, but you")
            print("can also set a custom range if you want.")
        }
        ```
        
        이 함수는 환영 메시지를 출력하는 네 개의 `print` 문으로 구성됩니다.
- **호출:**
    - 함수를 실행하려면 함수 이름을 괄호 `()`와 함께 호출합니다 (예: `showWelcome()`).
    - 함수가 호출되는 위치를 **호출 지점(call site)**이라고 합니다.

---

#### **3. 함수 매개변수 (Parameters)**

- **정의 및 목적:** 매개변수는 함수의 동작을 사용자 정의하기 위해 데이터를 함수에 전달하는 방법입니다. 매개변수는 함수에 유연성을 더합니다.
- **정의 방법:**
    - 함수 정의 시 괄호 `()` 안에 `parameterName: Type` 형식으로 매개변수를 지정합니다 (예: `number: Int`).
    - 매개변수는 함수 내부에서 상수로 사용될 수 있습니다.
- **호출 시 매개변수 사용:**
    - 함수를 호출할 때 매개변수 이름을 명시적으로 작성해야 합니다 (예: `printTimesTables(number: 5)`). 이는 Swift에서 각 매개변수의 기능을 명확하게 보여주는 데 유용합니다.
- **여러 매개변수:**
    - 여러 매개변수를 사용할 수 있으며, 이 경우 매개변수 명명이 더욱 중요해집니다.
    - **예시:** `printTimesTables(number: Int, end: Int)`는 `number`와 `end`라는 두 개의 정수 매개변수를 받습니다.
    - 함수 호출 시 매개변수 순서를 반드시 지켜야 합니다.
- **매개변수 vs. 인수 (Arguments):**
    - **매개변수 (Parameters):** 함수 정의 시 사용되는 플레이스홀더 이름입니다 (예: `number`와 `end`는 `printTimesTables` 함수의 매개변수). 함수 내부에서 해당 값에 대한 이름을 갖게 됩니다.
    - **인수 (Arguments):** 함수 호출 시 전달되는 실제 값입니다 (예: `printTimesTables(number: 5, end: 20)`에서 `5`와 `20`은 인수).
    - 대부분의 개발자 (Paul Hudson 포함)는 이 구분을 무시하고 두 가지 모두에 '매개변수'라는 용어를 사용합니다.
- **매개변수 디버깅 (True/False 사례 참고):**
    - `True` 사례는 올바른 매개변수 정의와 호출을 보여줍니다 (예: `count(to: Int)`, `format(number: Int)`).
    - `False` 사례는 매개변수 타입 불일치, 호출 시 매개변수 이름 불일치, 또는 매개변수 개수 불일치 등의 오류를 보여줍니다 (예: `walkDogs(to: "the park")` -> `destination: String`인데 `to:`로 호출, `driveRace(laps: 100)` -> `laps: String`인데 `Int` 전달).

**맞는 내용 (True) 예시:**

```
func format(number: Int) {
    print("The number is \(number).")
}

format(number: 32)
```

이 코드는 올바른 함수 호출과 매개변수 사용을 보여줍니다. format 함수는 Int 타입의 number라는 매개변수를 예상하며, 호출 시 format(number: 32)와 같이 매개변수 레이블과 함께 적절한 타입의 값(32)이 전달됩니다. Swift는 함수를 정의할 때 나열된 순서대로 값을 전달하도록 강제합니다.

**틀린 내용 (False) 예시:**

```
func walkDogs(to destination: String) {
    print("Let's go for a walk to \(destination).")
}

walkDogs(to: "the park")
```

이 코드는 함수 정의 시 매개변수 레이블이 destination으로 명시되었음에도 불구하고, 함수 호출 시 to라는 다른 레이블을 사용했기 때문에 False에 해당합니다. Swift에서는 매개변수 이름이 함수 호출 지점에서 매우 중요하며, 정의된 매개변수 이름을 명시적으로 작성해야 합니다. 때로는 매개변수에 외부 이름을 지정하지 않거나(언더스코어 _ 사용) 외부 이름과 내부 이름을 다르게 지정할 수 있지만..., 이 예시의 경우 정의된 외부 이름과 다른 이름으로 호출하여 오류를 발생시킵니다.

---

#### **4. 매개변수 레이블 사용자 지정**

Swift는 매개변수 레이블을 제어하는 두 가지 주요 방법을 제공하여 코드 가독성을 높입니다.

- **1. 외부 매개변수 레이블 생략 (`_` 사용):**
    - 때로는 매개변수 레이블이 불필요하거나 중복되어 보일 수 있습니다.
    - 매개변수 이름 앞에 밑줄 (`_`)을 추가하면 외부 매개변수 레이블을 제거할 수 있습니다.
    - **예시:** `hasPrefix("I see")` 함수는 `prefix`라는 매개변수를 받지만, 호출 시에는 `hasPrefix(prefix: "I see")` 대신 `hasPrefix("I see")`로 호출됩니다. 이는 `_`가 외부 이름으로 지정되었기 때문입니다.
    - `func isUppercase(string: String)`를 `func isUppercase(_ string: String)`로 변경하면 호출 시 `isUppercase(string: string)` 대신 `isUppercase(string)`로 쓸 수 있습니다.(`string: string`에서 뒤에 있는 `string`은 이미 저장된 변수나 상수이다.)
    - `append()`, `contains()`와 같은 Swift의 많은 내장 함수에서 이 방식이 사용됩니다.
    - Objective-C와의 상호 운용성을 위해 첫 번째 매개변수 레이블에 밑줄이 있는 함수를 많이 볼 수 있습니다.
- **2. 외부 및 내부 매개변수 이름 분리:**
    - 외부 매개변수 이름이 호출 지점에서 자연스럽게 읽히면서도, 함수 내부에서는 다른 이름으로 사용하고 싶을 때 사용합니다.
    - `externalName internalName: Type` 형식으로 매개변수를 정의합니다.
    - **예시:** `printTimesTables(number: Int)` 대신 `func rintTimesTables(for number: Int)`로 정의할 수 있습니다.
        - 호출 시에는 `printTimesTables(for: 5)`처럼 외부 이름 `for`를 사용합니다.
        - 함수 내부에서는 `for` 대신 `number`라는 내부 이름을 사용하여 코드를 작성합니다.
        - `for`와 같은 키워드는 외부 이름으로는 허용되지만, 함수 내부에서는 키워드로 사용될 수 없기 때문에 이 방식이 유용합니다.
- **매개변수 레이블의 중요성:**
    - 코드를 6개월 후에 다시 볼 때도 `rollDice(sides: 6, count: 4)`처럼 무엇을 하는지 명확하게 이해할 수 있도록 돕습니다.
    - Swift에서는 동일한 함수 이름을 가진 여러 함수를 매개변수 이름으로 구분합니다 (함수 오버로드, 예: `hireEmployee(name: String)`, `hireEmployee(title: String)`, `hireEmployee(location: String)`). 다른 언어에서는 흔하지 않지만 Swift에서는 매우 일반적인 방식입니다.

---

#### **5. 함수에서 값 반환하기**

함수는 내부적으로 계산을 수행한 다음 그 결과를 호출 지점으로 다시 전달할 수 있습니다.

- **단일 값 반환:**
    - 함수 정의 시 반환할 데이터의 **타입**을 명시해야 합니다. 함수 이름 뒤에 `->`와 반환 타입을 작성합니다 (예: `func rollDice() -> Int`).
    - 함수 본문 내에서 `return` 키워드를 사용하여 실제 데이터를 반환합니다 (예: `return Int.random(in: 1...6)`).
    - Swift는 함수가 약속한 타입의 값을 항상 반환하도록 엄격하게 강제합니다.
    - **예시:** `sqrt(169)`는 `169`의 제곱근인 `13.0`을 반환합니다. (sqrt는 기본 제공 함수)`areLettersIdentical(string1: String, string2: String) -> Bool` 함수는 두 문자열을 비교하여 `Bool` 값을 반환합니다.
- **`return` 키워드 생략 조건:**
    - 함수 본문에 **단일 표현식(single expression)**만 포함된 경우 `return` 키워드를 생략할 수 있습니다.
    - **표현식 (Expression):** `5 + 8`이나 `greet("Paul")`처럼 단일 값으로 변환되는 코드 줄. `print()` 호출처럼 값을 반환하지 않는 것은 표현식이 아닙니다.
    - **명령문 (Statement):** 변수를 생성하거나, 루프를 시작하거나, 조건을 확인하는 등의 작업을 수행하는 것. `let name = "Otis"`는 명령문입니다.
    - `if` 또는 `switch` 문도 각 분기가 단일 표현식인 경우 `return`을 생략할 수 있습니다. 그러나 새로운 상수를 생성한 후 반환하는 것은 허용되지 않습니다.
    - **예시:**
        
        ```
        func doMoreMath() -> Int {
            5 + 5 // 'return' 키워드 생략 가능
        }
        func areLettersIdentical(string1: String, string2: String) -> Bool {
            string1.sorted() == string2.sorted() // 'return' 키워드 생략 가능
        }
        func pythagoras(a: Double, b: Double) -> Double {
            sqrt(a * a + b * b) // 'return' 키워드 생략 가능
        }
        ```
        
- **함수 즉시 종료 (`return` 단독 사용):**
    - 함수가 값을 반환하지 않더라도 `return` 키워드를 단독으로 사용하여 함수 실행을 즉시 중단할 수 있습니다. 특정 조건에서 함수를 더 이상 진행하지 않도록 할 때 유용합니다.
```
func processUserData(username: String, age: Int) {
    if username.isEmpty {
        print("오류: 사용자 이름이 비어 있습니다. 처리를 중단합니다.")
        return
    }

    if age < 0 {
        print("오류: 나이가 유효하지 않습니다. 처리를 중단합니다.")
        return // 함수 즉시 종료 [1, 8]
    }

    print("\(username)님, 환영합니다! 나이: \(age)")
    // 추가적인 사용자 데이터 처리 로직...
}

processUserData(username: "", age: 25) // 사용자 이름이 비어 있으므로 즉시 종료
processUserData(username: "철수", age: -5) // 나이가 유효하지 않아 즉시 종료
processUserData(username: "영희", age: 30) // 정상적으로 실행
```

---

#### **6. 함수에서 여러 값 반환하기: 튜플 (Tuples) 활용**

함수에서 두 개 이상의 값을 반환해야 할 때 튜플은 배열이나 딕셔너리보다 더 나은 해결책을 제공합니다.

- **배열 (`Array`)의 한계:**
    - `getUser()` 함수가 `["Taylor", "Swift"]`와 같은 배열을 반환할 때, `user`와 `user`가 각각 무엇을 의미하는지 기억하기 어렵습니다.
    - 배열의 데이터가 조정되면 인덱스가 가리키는 값이 바뀌거나 아예 존재하지 않을 수도 있습니다.
- **딕셔너리 (`Dictionary`)의 한계:**
    - `["firstName": "Taylor", "lastName": "Swift"]`와 같은 딕셔너리를 반환하면 값에 의미 있는 이름을 붙일 수 있습니다.
    - 하지만 Swift는 딕셔너리의 특정 키가 존재하는지 컴파일 시점에 알 수 없으므로, 값을 읽을 때 기본값 (예: `default: "Anonymous"`)을 제공해야 하는 번거로움이 있습니다.
    - 딕셔너리는 임의의 수많은 다른 값을 포함할 수 있어, 요청한 값이 반드시 존재한다고 보장할 수 없습니다.
- **튜플 (`Tuple`)의 장점:**
    - 튜플은 여러 값을 하나의 변수에 담을 수 있습니다.
    - 다른 데이터 구조와 달리 **크기가 고정되어 있고** (예: 항상 2개의 값) **다양한 데이터 타입을** (예: `String`과 `Int` 조합) 쉽게 가질 수 있습니다.
    - **정의 및 사용:**
        - 반환 타입으로 튜플을 정의할 때 각 값에 이름 (레이블)을 부여할 수 있습니다 (예: `(firstName: String, lastName: String)`).
        - 튜플의 각 항목은 고유한 이름을 가지며, 이는 딕셔너리의 임의 키와 다릅니다.
        - Swift는 튜플의 특정 값이 존재하고 어떤 타입인지 컴파일 시점에 보장합니다. 따라서 `user.firstName`처럼 점 구문으로 접근하며, 오타의 가능성이 없습니다.
        - **예시:**
            
```
func getUser() -> (firstName: String, lastName: String) {
    (firstName: "Taylor", lastName: "Swift")
}
let user = getUser()
print("Name: \(user.firstName) \(user.lastName)") // 'user.firstName'으로 접근
```
            
    - **반환 시 튜플 요소 이름 생략:**
        - 함수에서 튜플을 반환할 때, 반환 타입에 이미 이름이 지정되어 있으므로 `return` 문에서 튜플 요소의 이름을 반복할 필요가 없습니다 (예: `("Taylor", "Swift")`만으로도 `firstName`과 `lastName`에 매칭됨).
    - **이름 없는 튜플:**
        - 튜플 요소에 이름이 없는 경우, `user.0`, `user.1`과 같이 0부터 시작하는 숫자 인덱스를 사용하여 접근할 수 있습니다.ㅗ
        - 명명된 튜플에도 숫자 인덱스 접근이 가능하지만, 이름을 사용하는 것이 더 명확합니다.
    - **튜플 디스트럭처링 (Destructuring):**
        - 함수가 반환한 튜플을 개별 상수로 바로 분리하여 사용할 수 있습니다.
        - **예시:** `let (firstName, lastName) = getUser()`는 `getUser()`가 반환한 튜플의 `firstName`과 `lastName`을 각각의 상수에 할당합니다.
        - 필요 없는 튜플 요소는 밑줄 `_`를 사용하여 무시할 수 있습니다 (예: `let (firstName, _) = getUser()`).
- **튜플 사용 시기:**
    - 정확히 두 개의 문자열, 또는 정확히 두 개의 문자열과 정수, 또는 정확히 세 개의 부울 값 등 고정된 개수와 유형의 값을 보관해야 할 때 사용합니다.
    - 할 일 목록처럼 순서가 예측 가능할 때 효과적입니다.

---

#### **7. 함수 디버깅 및 코드 품질**

- **함수 작성, 매개변수, 반환 값 디버깅:**
    - 제공된 `True/False` 예시들을 통해 함수 정의, 매개변수 전달, 반환 값 처리 시 발생할 수 있는 일반적인 오류 유형을 익힐 수 있습니다. `False` 예시들은 문법 오류, 타입 불일치, 매개변수 누락, 키워드 오타 등을 포함합니다.
- **함수 매개변수 개수 (코드 냄새 `Code Smell`):**
    - 함수가 너무 많은 매개변수 (주관적이지만 6개 이상)를 받는 경우, 이는 해당 함수가 너무 많은 작업을 수행하고 있다는 "코드 냄새"일 수 있습니다.
    - 이런 경우 함수를 더 작고 구체적인 함수로 분할하는 것을 고려해야 합니다. 이는 코드 구성 방식에 근본적인 문제가 있음을 암시할 수 있습니다.

---

이 가이드를 통해 Swift 함수의 기본부터 고급 개념까지 체계적으로 학습하실 수 있습니다. 각 섹션의 예시와 설명은 실제 코딩에 적용하는 데 큰 도움이 될 것입니다.